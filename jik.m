clear all;

clear all;

##
## Перестановки циклов в умножении матриц
##
## Ниже реализованы различные варианты упорядочения циклов при умножении матриц.
## Каждый вариант характеризуется своим способом доступа к данным и доминирующей
## операцией (скалярное произведение или saxpy)
##

## Функция f1: реализует умножение матриц в порядке циклов jik
## - Внутренний цикл (k): скалярное произведение
## - Средний цикл (i): обрабатывает строки матрицы C
## - Внешний цикл (j): обрабатывает столбцы матрицы C
## - Доступ к данным: j на столбец, i на строку
function C = f1(A, B, n)
    C = zeros(n, n);

    for j = 1:n

        for i = 1:n

            for k = 1:n
                C(i, j) = C(i, j) + A(i, k) * B(k, j); % Скалярное произведение строки i матрицы A на столбец j матрицы B
            endfor

        endfor

    endfor

    printf("f1. Норма = %d\n", norm(A * B - C));
endfunction

## Функция f2: реализует умножение матриц с векторизацией внутреннего цикла (порядок jik)
## - Операция A(i, :) * B(:, j): скалярное произведение векторов
## - Средний цикл (i): матрица × вектор
## - Внешний цикл (j): обработка по столбцам
## - Доступ к данным: j на столбец, i на строку
function C = f2(A, B, n)
    C = zeros(n, n);

    for j = 1:n

        for i = 1:n
            C(i, j) = C(i, j) + A(i, :) * B(:, j); % Векторизованное скалярное произведение
        endfor

    endfor

    printf("f2. Норма = %d\n", norm(A * B - C));
endfunction

## Функция f3: реализует умножение матриц с полной векторизацией внутренних циклов
## - Операция C(:, j) = C(:, j) + A * B(:, j): матрично-векторное произведение (GAXPY)
## - Внешний цикл (j): обработка по столбцам
## - Особенность: вычисление целого столбца результата за одну операцию
function C = f3 (A, B, n)
    C = zeros(n, n);

    for j = 1:n
        C(:, j) = C(:, j) + A * B(:, j); % GAXPY операция (матрица × вектор + вектор)
    endfor

    printf("f3. Норма = %d\n", norm(A * B - C));
endfunction

## Функция f4: реализует блочное умножение матриц
## - Разбивает матрицы на блоки размером alpha×alpha
## - Оптимизирует локальность данных для более эффективного использования кэш-памяти
## - Использует принцип умножения блочных матриц: C(i,j) = Сумма(A(i,k) * B(k,j))
function f4 (A, B, n, N, alpha)

    C = zeros(n, n);

    for jb = 1:N
        j = (jb - 1) * alpha + 1:jb * alpha; % Диапазон индексов j-блока

        for ib = 1:N
            i = (ib - 1) * alpha + 1:ib * alpha; % Диапазон индексов i-блока

            for kb = 1:N
                k = (kb - 1) * alpha + 1:kb * alpha; % Диапазон индексов k-блока

                C(i, j) = C(i, j) + A(i, k) * B(k, j); % Умножение блоков матриц
            endfor

        endfor

    endfor

    printf("f4. Норма = %d\n", norm(A * B - C));
endfunction

## Основная часть: тестирование и сравнение производительности различных реализаций
n = 20;
A = rand(n, n); B = rand(n, n); % Матрицы заполняются случайными числами от 0 до 1
alpha = 5; % Размер блока
N = n / alpha; % Количество блоков

## Измерение времени выполнения для каждой функции
tic;
f1(A, B, n);
time_f1 = toc;
printf("Время выполнения f1: %f секунд\n", time_f1);

tic;
f2(A, B, n);
time_f2 = toc;
printf("Время выполнения f2: %f секунд\n", time_f2);

tic;
f3(A, B, n);
time_f3 = toc;
printf("Время выполнения f3: %f секунд\n", time_f3);

tic;
f4(A, B, n, N, alpha);
time_f4 = toc;
printf("Время выполнения f4: %f секунд\n", time_f4);

# iterations = 50;
# time_f4 = 0;
# for i = 1:iterations
#     tic;
#     f4(A, B, n, N, alpha);
#     time_f4 = time_f4 + toc;
# endfor
# time_f4 = time_f4 / iterations;
# printf("Среднее время f4: %f секунд\n", time_f4);
