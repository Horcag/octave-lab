clear all;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% БЛОЧНЫЙ АЛГОРИТМ РЕШЕНИЯ НИЖНЕТРЕУГОЛЬНОЙ СИСТЕМЫ УРАВНЕНИЙ
%
% ОПИСАНИЕ:
% Эта функция реализует блочный вариант алгоритма прямой подстановки
% для решения системы линейных уравнений LX = B, где:
% - L: нижнетреугольная матрица размера n×n
% - B: матрица правых частей размера n×m
% - X: искомая матрица решений размера n×m
%
% ПРЕИМУЩЕСТВА БЛОЧНОГО ПОДХОДА:
% 1. Лучшая локальность данных, что снижает количество кэш-промахов
% 2. Возможность использования оптимизированных BLAS операций над блоками
% 3. Более эффективное использование параллелизма
%
% ПАРАМЕТРЫ:
% L - нижнетреугольная матрица коэффициентов
% B - матрица правых частей
% p - размер блока (n должно делиться на p без остатка)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function X = block_forward_substitution(L, B, p)
    % Определяем размеры входных матриц:
    % n - количество строк/столбцов в L (квадратная матрица)
    % m - количество столбцов в B (количество систем для решения)
    n = size(L, 1); % Размер матрицы L (количество строк)
    m = size(B, 2); % Количество столбцов в B

    % Вычисляем количество блоков r = n/p
    % Весь алгоритм основан на разделении матриц L, B и X на блоки размера p×p
    r = n / p; % Количество блоков (предполагается, что n делится на p)

    % Создаем матрицу результата, заполненную нулями
    % В процессе работы алгоритма она будет заполняться решением
    X = zeros(n, m); % Инициализация результата

    % Основной цикл по блокам строк матрицы L
    % i изменяется от 1 до r, где r - количество блоков
    for i = 1:r
        % Вычисляем индексы строк текущего диагонального блока L_ii
        % Например, если p=2 и i=2, то rows_Lii = [3, 4]
        rows_Lii = (i - 1) * p + 1:i * p; % Индексы строк для текущего блока Lii
        
        % Извлекаем текущий диагональный блок L_ii размера p×p
        % Этот блок будет использован для решения системы уравнений
        Lii = L(rows_Lii, rows_Lii); % Диагональный блок L

        % Индексы для соответствующих строк в матрице B
        % Извлекаем подблок B_i из матрицы B
        rows_Bii = (i - 1) * p + 1:i * p; % Индексы строк для текущего блока B
        Bi = B(rows_Bii, :); % Текущий блок B

        % Инициализируем матрицу S для накопления суммы L_ij * X_j
        % Эта сумма представляет влияние уже найденных блоков X_j на текущий блок
        S = zeros(p, m); % Инициализация суммы для коррекции Bi

        % Внутренний цикл для вычисления суммы L_ij * X_j для всех j < i
        for j = 1:i - 1
            % Вычисляем индексы столбцов для блока L_ij
            % Например, если p=2 и j=1, то cols_Lij = [1, 2]
            cols_Lij = (j - 1) * p + 1:j * p; % Индексы столбцов для блока Lij
            
            % Извлекаем недиагональный блок L_ij размера p×p
            Lij = L(rows_Lii, cols_Lij); % Блок Lij
            
            % Извлекаем ранее вычисленный блок решения X_j
            Xj = X(cols_Lij, :); % Уже вычисленный блок Xj

            % Обновляем сумму: S = S + L_ij * X_j
            % Это матричное произведение размера p×m
            S = S + Lij * Xj; % Обновление суммы
        endfor

        % Вычисляем скорректированную правую часть:
        % B_i' = B_i - Σ(L_ij * X_j) для всех j < i
        Bii = Bi - S; % Коррекция блока B
        
        % Решаем систему L_ii * X_i = B_i'
        % Оператор "\" в Octave решает систему линейных уравнений
        Xi = Lii \ Bii; % Решение для текущего блока
        
        % Сохраняем найденный блок решения X_i в соответствующие позиции матрицы X
        X(rows_Lii, :) = Xi; % Сохранение результата
    endfor
endfunction

% ТЕСТИРОВАНИЕ ФУНКЦИИ:
% Создаем тестовые матрицы и проверяем правильность работы алгоритма

n = 100; m = 50; % Размеры матриц
r = 50; % Размер блока
L = tril(rand(n, n)); % Создаем случайную нижнетреугольную матрицу
L = L + diag(rand(n, 1) + 1); % Диагональные элементы от 1 до 2 (невырожденная L)
B = rand(n, m); % Создаем случайную матрицу правых частей

% Применяем нашу блочную функцию для решения системы
X = block_forward_substitution(L, B, r);

% Используем встроенную функцию для проверки (эталонное решение)
X_expected = L \ B; % Стандартное решение

% Сравниваем результаты: вычисляем норму разности между нашим решением и эталонным
printf("Норма разности X и X_expected = %d\n", norm(X - X_expected));
% Если норма близка к нулю (порядка 1e-15), значит алгоритм работает корректно