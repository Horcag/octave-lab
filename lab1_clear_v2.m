clear all;

% БЛОЧНЫЙ АЛГОРИТМ РЕШЕНИЯ НИЖНЕТРЕУГОЛЬНОЙ СИСТЕМЫ УРАВНЕНИЙ
% Функция реализует блочный вариант алгоритма прямой подстановки
% для решения системы линейных уравнений LX = B.
% Параметры:
% L - нижнетреугольная матрица коэффициентов
% B - матрица правых частей
% p - размер блока (n должно делиться на p без остатка)
function X = block_forward_substitution(L, B, r)
    % Определяем размеры матриц
    n = size(L, 1);  % Размер матрицы L
    m = size(B, 2);  % Количество столбцов в B
    N = ceil(n / r); % Количество блоков

    % Разбиваем матрицы на блоки
    X = zeros(n, m);  % Матрица решений

    % Основной цикл по блокам (по столбцам, как в учебнике)
    for j = 1:N
        % Определяем индексы текущего блока по столбцам
        cols_Ljj = (j-1)*r + 1 : j*r;
        
        % Извлекаем диагональный блок L_{jj}
        Ljj = L(cols_Ljj, cols_Ljj);
        
        % Извлекаем блок правой части B_j
        Bj = B(cols_Ljj, :);
        
        % Решаем подсистему L_{jj} X_j = B_j
        Xj = Ljj \ Bj;
        
        % Сохраняем решение блока
        X(cols_Ljj, :) = Xj;
        
        % Обновляем последующие блоки
        for i = j+1:N
            % Определяем индексы строк следующего блока
            cols_Lij = (j-1)*r + 1 : j*r;
            rows_Bi = (i-1)*r + 1 : i*r;
            
            % Извлекаем блок L_{ij}
            Lij = L(rows_Bi, cols_Lij);
            
            % Извлекаем и обновляем блок B_i
            Bi = B(rows_Bi, :);
            B(rows_Bi, :) = Bi - Lij * Xj;
        end
    end
endfunction

% Тестовый пример
L = [2 0 0 0 0 0; 
     2 4 0 0 0 0; 
     4 2 6 0 0 0; 
     2 4 3 4 0 0;
     1 3 4 1 4 0;
     3 4 1 2 5 1]; %
B = [2; 10; 26; 35; 43; 53]; %
p = 2;
X = block_forward_substitution(L, B, p);

X

n = 100; m = 50; % Размеры матриц
r = 50; % Размер блока
L = tril(rand(n, n)); % Создаем случайную нижнетреугольную матрицу
L = L + diag(rand(n, 1) + 1); % Диагональные элементы от 1 до 2 (невырожденная L)
B = rand(n, m); % Создаем случайную матрицу правых частей

% Применяем нашу блочную функцию для решения системы
X = block_forward_substitution(L, B, r);

% Используем встроенную функцию для проверки (эталонное решение)
X_expected = L \ B; % Стандартное решение

% Сравниваем результаты: вычисляем норму разности между нашим решением и эталонным
printf("Норма разности X и X_expected = %d\n", norm(X - X_expected));
% Если норма близка к нулю (порядка 1e-15), значит алгоритм работает корректно
